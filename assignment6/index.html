<html>
 <!-- MoSIS Assignments template -->

 <title>MoSIS Assignment 6</title>

 <p bgcolor="#ffffff">

 <hr noshade>

   <h1>MoSIS Assignment 6</h1>

    <h2>Team</h2>
     <pre>
      Name       :	Daniëlle Jongstra
      Student ID :	20172260
      e-mail     :	Danielle.jongstra@student.uantwerpen.be

      Name       :	Joanna Kisaakye
      Student ID :	20205490
      e-mail     :	joanna.kisaakye@student.uantwerpen.be

      Time spent on this assignment (in hours): 40 hours
     </pre>

 
 <h2>Requirements : </h2>
 <p>
 On top of the requirements listed as part of the assignment description, we had the following requirements:
 <ol>
	 <li>
		 Each machine maintains state that describes the current situation within the machine.
	 </li>
	 <li>
		 There are 4 hierarchical types of machines:
		 <ol>
			 <li> the type that produces raw materials such as the Cube and the Cylinder</li>
			 <li> the type that processes inputs one at a time and has a queue</li>
			 <li> the type that assembles raw materials into a new output</li>
			 <li> the type that collects items, which may either pass them onto the next machine or not.</li>
		 </ol>
	 </li>
	 <li>
		 There are two types of raw materials, the Cube and the Cylinder.
	 </li>
	 <li>
		 The state of a product is stored within the product, and is updated during processing. It includes:
		 <ol>
			 <li>
				 The creation time.
			 </li>
			 <li>
				 The time it enters a queue.
			 </li>
			 <li>
				 The start time of a process on the product.
			 </li>
			 <li>
				 The correctness of the product.
			 </li>
			 <li>
				 The number of times the product has been reassembled.
			 </li>
		 </ol>
	 </li>
	 <li>
		 There is a separate object required to collect statistical data about the whole model.
	 </li>
 </ol>
 </p>
 <h2>Assumptions : </h2>
 <p>
 The assumption made in our models include:
 <ol>
	 <li>
		 Machines never power on or off, they are either in an idle state or processing state.
	 </li>
	 <li>
		The correctness value of a product determines whether the product is accepted, trashed or sent to be fixed.
	 </li>
 </ol>
 </p>
 <h2>Design : </h2>
 <figure>
	 <img src="./img/DEVS Model Design.jpg">
	 <figcaption>Figure 1: Class Diagram Summarising DEVS model design</figcaption>
 </figure>
 <h4>DEVS models</h4>
 <p>
 Our design consists of 5 atomic DEVS models and one Coupled DEVS model that include:
 <ol>
	 <li>
		 The <b>ObjectSource</b> model:
		 <br>
		 This model produces the <i>"Cube"</i> and <i>"Cylinder"</i> raw materials required to assemble a product, it only has one output port.
	 </li>
	 <li>
		 The <b>Operator</b> model:
		 <br>
		 This model processes a Product at a time, it has a queue, mean standard deviation, and a seed . It has two sub models:
		 <ol>
			 <li>
				 The <b>Assembler</b>:
				 Has one output port for assembled products.
			 </li>
			 <li>
				 The <b>Inspector</b>:
				 Has 3 different output ports that for accepted products, rejected products and products that will have to be fixed/reassembled.<br>
				 To determine these, the assembler also has 3 "part" attributes that hold the ratios to be used to determine where to send products.
			 </li>
		 </ol>
	 </li>
	 <li>
		 The <b>Preassembler</b> model:
		 <br>
		 This model produces a product after it has acquired enough <i>"Cubes"</i> and <i>"Cylinders"</i>. The Preassembler has one input port <i>"in_object"</i> to which both object sources are connected.
	 </li>
	 <li>
		 The <b>FATmachine</b> model:
		 <br>
		 This model collects assembled products and keeps the count of total products collected and total products collected that were reassembled as part of its state. This model has 3 sub models:
		 <ol>
			 <li>
				 The <b>Fix</b>:
				 Has one output port so that it can pass on assembled products to be reassembled.
			 </li>
			 <li>
				 The <b>Accept</b>:
				 Collects assembled items and keeps track of reassembled items that have been accepted as well as all accepted items.
			 </li>
			 <li>
				 The <b>Trash</b>:
				 Collects assembled items and keeps track of all rejected items.
			 </li>
		 </ol>
	 </li>
	 <li>
		 The <b>Statistics</b> model:
		 <br>
		 This model keeps track of the global state of the System coupled DEVS model. It has two input ports <i>"in_queuetimes"</i> and <i>"in_product"</i>. The <i>"waitingTimes"</i> attribute collects the times spent by products in the queues of the inspector and assembler.<br>
		 The <i>"totalTimes"</i> list keeps track of the total time each product has spent in the system from the point of assembly.
		 <br>
		 The <i>"getAverageTotalTime"</i> function returns the mean of the total times. The <i>"getAverageWaitingTime"</i> function returns the mean of the waiting times.
	 </li>
	 <li>
		 The <b>Factory</b> model:
		 <br>
		 This is the CoupledDEVS model that brings all the atomic models together.
	 </li>
 </ol>
 Each of the models is composed of a separate <i>"State"</i> object that contains data about the current situation within the machine, such as the current time, the remaining time, the current product, the number of items in the queue, the queue, waiting times and so on. This allows us to separate the current state of the model from it's behaviour and it also allows us to easily collect analytical data.
 <br>
 Each of the models above, apart from the ObjectSource model, also interacts with a <b>Product</b> object in one way or the other.

 <h4>Product</h4>
 	The product class represents the actual products assembled by the system. Each product also tracks it's creation time, it's arrival time at a process, time it has spent in a queue, the number of times it has been reassembled and it's correctness measure.
 </p>
 <h2>Implementation : </h2>
 <p>Our solution is implemented in PythonPDEVS, the detailed description of the model files is below:</p>
 <h4><a href="./FATMachines.py">FATMachines.py</a></h4>
 <p>
	 This file contains the definition of the FATmachines atomic DEVS model, its 3 sub models, <b>Accept</b>, <b>Fix</b> and <b>Trash</b> as well as the definition of its <b>State</b>.
	 <br>
	 The attributes of the <b>State</b> include:
	 <ol>
		 <li>
			 active : a boolean specifying whether this machine is working at the moment. The time advance function uses this boolean to determine the time to return.
		 </li>
		 <li>
			 current: the current product being worked on
		 </li>
		 <li>
			 total: the total number of products received by this machine, not set for fix.
		 </li>
		 <li>
			 reassembled: the total number of products received by this machine that were reassembled, only used for accept.
		 </li>
	 </ol>
	 <br>
	 The internal transition function marks the FATmachine model as inactive. The external transition function marks the model as active and makes the incoming product the current product.
	 <br>The output function simply returns the current product, so that the product can be used by the next DEVS.
	 <br> <br>
	 The three sub models each have their own external transition function that call the superclass its external transition function. In this sub function the class specific parameters that do not have to do with sending the product to output are set.
	 <ul>
		<li>
		Fix: Increase the amount of times the product has been reassembled with 1.
		</li>
		<li>
		Accept: add 1 to the the total amount of products that have been accepted. Also check if it has been reassembled and add 1 to total amount of products reassembled for this class.
		</li>
		<li>
		Trash: add 1 to the the total amount of products that have been trashed.
		</li>
	 
	 </ul>
 </p>


 <h4><a href="./ObjectSource.py">ObjectSource.py</a></h4>
 <p>
	 This file contains the definition of the ObjectSource atomic DEVS model. It is a very simple model which has one output port and one other attribute which is the time.
	 <br>
	 <ol>
		 <li>
			 time: This is a Float that indicates how long this source takes to produce a raw material item. It is the time returned by the time advance function.
		 </li>
	 </ol>
	 <br>The output function simply returns the model name, which represents the raw material being produced by the machine. The initialization function set the appropriate name and time for different sources.
	 These values are given in the coupled DEVS "system".
 </p>

 <h4><a href="./Operator.py">Operator.py</a></h4>
 <p>
	 This file contains the definition of the Operator atomic DEVS model, its 2 sub models, <b>Assembler</b> and <b>Inspector</b> as well as the definition of its <b>State</b>.
	 <br>
	 The attributes of the <b>OperatorState</b> include:
	 <ol>
		 <li>
			 queue : an list that holds received products.
		 </li>
		 <li>
			 currentTime: the current simulated time of this model.
		 </li>
		 <li>
			 remainingTime: the time remaining for the operator to finish the current product.
		 </li>
		 <li>
			 productProcessing: the current product being worked on.
		 </li>
	 </ol>
	 <br>
	 In addition to the state, the other attributes of the <b>Operator</b> include:
	 <ol>
		 <li>
			 mean : the mean to be used when generating ransom numbers.
		 </li>
		 <li>
			 standardDeviation: the standard Deviation to be used when generating random numbers.
		 </li>
		 <li>
			 seed: the seed for the random number generators.
		 </li>
		 <li>
			 in_product: the input port.
		 </li>
		 <li>
			 out_stats: the output port for the statistics, used to pass the time a product waited in the queue to the statistics DEVS.
		 </li>
	 </ol>
     <br>
	 The Operator model essentially overrides the following functions of the AtomicDEVS model:
	 <ol>
		 <li>
			 extTransition : Upon receipt of an item, the external transition function updates the currentTime with the elapsed time. This value is then set in the product as its queue time and the product is appended to the queue.
			 <br>If the remaining time is INFINITY i.e. the machine is idle, the product is allowed to enter the machine for processing via the enterOperator() function.
			 <br>Otherwise, the remaining time is reduced by the elapsed time.
		 </li>
		 <li>
			 intTransition: This function removes an item from the queue, if there are no more items in the queue, then the machine is marked as idle.
			 <br>If that is not the case, another product is allowed in for processing by using the enterOperator() function.
		 </li>
		 <li>
			 timeAdvance: returns the remaining time, if the remaining time is less than 0, it returns zero.
		 </li>
	 </ol>
 <br>
 The <b>enterOperator</b> function is responsible for setting the time that this machine is going to take to process an item, based on the mean and standard deviation provided at the point of instantiation.
 <br>It also sets the entry time of the product as the the machines current simulated time and sets the product as the current product processing.
 </p>

 <h5>The Assembler</h5>
 <p>
	 The main feature of the Assembler is that it has one extra output port for the products assembled and the following functions are overridden:
     <ol>
		 <li>
			 outputFnc : Both the time spent in the queue of the product and the product itself are outputs, albeit to different destinations.
		 </li>
		 <li>
			 extTransition: Upon receipt of a product, the assembler sets its correctness before letting its parent function proceed.
		 </li>
	 </ol>
 </p>

 <h5>The Inspector</h5>
 <p>
	 The main feature of the Inspector is that it has 3 additional attributes that specify the cutoff ratios of correctness and three outputs. The trashPart and the fixPart are inputs to the constructor. The acceptPart however is calculated using the other part to ensure the sums do not exceed 1.
	 <br>The following functions are also overridden:
     <ol>
		 <li>
			 outputFnc : Both the time spent in the queue of the product and the product itself are outputs, albeit to different destinations. The timeInQueue is sent to the <b>Statistics</b> model but the product is sent to it's next destination according to it's correctness.
			 <br>the products destination depends on where the correctness lies in the range of the trashPart, fixPart and acceptPart.
		 </li>
	 </ol>
 </p>

 <h4><a href="./Preassembler.py">Preassembler.py</a></h4>
 <p>
	 This file contains the definition of the Preassembler atomic DEVS model and the definition of its <b>State</b>.
	 <br>
	 The attributes of the <b>PreassemblerState</b> include:
	 <ol>
		 <li>
			 cylinders : a counter for cylinders received.
		 </li>
		 <li>
			 cubes: a counter for cubes received.
		 </li>
		 <li>
			 time: the current time of the model used to set the creation time of a product.
		 </li>
	 </ol>
	 <br>
	 In addition to the state, the other attributes of the <b>Preassembler</b> include:
	 <ol>
		 <li>
			 in_object : the input port.
		 </li>
		 <li>
			 out_product: the output port.
		 </li>
	 </ol>
     <br>
	 The Operator model overrides the following functions of the AtomicDEVS model:
	 <ol>
		 <li>
			 extTransition : Updates the current simulated time of the machine to the elapsed time and increments the counters according to the type of the input.
		 </li>
		 <li>
			 intTransition: Reduces the cube and cylinder counters by the amount needed of each to create a product.
		 </li>
		 <li>
			 timeAdvance: marks the machine as idle unless the required number of cubes and cylinders have been received at which point the time advance returns 0(an immediate transition).
		 </li>
		 <li>
			 outputFnc: returns an assembled product with the creation time set to the current time.
		 </li>
	 </ol>

 <h4><a href="./Statistics.py">Statistics.py</a></h4>
 <p>
	 This file contains the definition of the Statistics atomic DEVS model and the definition of its <b>State</b>.
	 <br>
	 The attributes of the <b>StatisticState</b> include:
	 <ol>
		 <li>
			 currentTime : the current simulated time of the entire system.
		 </li>
		 <li>
			 waitingTimes: an list of waiting times spent in the system by any product.
		 </li>
		 <li>
			 totalProducts: the product counter.
		 </li>
		 <li>
			 amountReassembled: the dictionary of reassembled products, keeping a counter of how many products have been reassembled a certain amount of times before being accepted or trashed.
		 </li>
		 <li>
			 totalTimes: the list of total times spent in the system by each product.
		 </li>
	 </ol>
	 <br>
	 In addition to the state, the other attributes of the <b>Statistics</b> include:
	 <ol>
		 <li>
			 in_queueTimes : the input port for product queue times.
		 </li>
		 <li>
			 in_product: the input port for products.
		 </li>
	 </ol>
     <br>
	 The Statistics model overrides the following functions of the AtomicDEVS model:
	 <ol>
		 <li>
			 extTransition : Upon receipt of inputs, the current time is updated with the elapsed time.
			 <br>A received queue time is added to the list of waiting times.
			 <br>When a product is received, the total number of products is incremented, the total time spent by the product in the system is calculated and added to the total times list.
			 <br>The amount of times this product has been reassembled is retrieved and if the that digit is already part of the dictionary, it's number is incremented. Otherwise a new entry is added for that digit with a value of 1.
		 </li>
	 </ol>
     <br>
	 The Statistics model provides the following helper functions, which is used mainly for reporting:
	 <ol>
		 <li>
			 getTime: Return the current simulated time.
		 </li>
		 <li>
			 getAverageWaitingTime: Returns the average waiting time.
		 </li>
		 <li>
			 getTotalProducts: Returns the total number of products assembled.
		 </li>
		 <li>
			 getReassemblies: Returns the total number of reassemblies observed in the form <i>{ number_of_reassemblies:number_of_products }</i>.
		 </li>
		 <li>
			 getAverageTotalTime: Returns the average time spent in the system by a product.
		 </li>
	 </ol>

 <h4><a href="./System.py">System.py</a></h4>
 <p>
	 This file contains the definition of the Factory coupled DEVS model.
     <br>
	 The Factory model provides the following helper functions, for use mainly for reporting:
	 <ol>
		 <li>
			 printStatistics: Writes out the statitics collected by the Statistics atomic model to a file.
		 </li>
	 </ol>
	 <br> 
	 The factory initializes the different models and connects the appropriate models.

 <h4><a href="./Product.py">Product.py</a></h4>
 <p>
	 This file contains the definition of the Product object processed by the system.
     <br>
	 The Product model provides the following helper functions, for use mainly for tracking its state:
	 <ol>
		 <li>
			 getCreationTime: Returns the time when it was created.
		 </li>
		 <li>
			 setEntryTime: Sets the time that it is admitted into a machine for processing.
		 </li>
		 <li>
			 setQueueTime: Sets the time spent in a queue.
		 </li>
		 <li>
			 getTimeInQueue: Returns the time spent in a queue.
		 </li>
		 <li>
			 getCorrectness: Returns the correctness measure.
		 </li>
		 <li>
			 setNewCorrectness: Calculates the new correctness measure based on the previous measure.
		 </li>
		 <li>
			 getAmountReas: Returns the count of reassemblies performed on this product.
		 </li>
		 <li>
			 increaseReas: Increases the count of reassemblies performed on this product by one.
		 </li>
	 </ol>

  <h4><a href="./Simulator.py">Simulator.py</a></h4>
 <p>
	 This file contains the simulation of the Factory coupled DEVS model.
 <br>

 <h2>Modelling and Simulation Results : </h2>

 <p>
    As can be seen from our simulation results in the following files, the percentage of items in the trash and the percentage of assembled items always add up to 100%:
    <ol>
        <li>
            <a href="./statsOriginal.txt">statsOriginal</a>
        </li>
        <li>
            <a href="./statsOtherInspector.txt">statsOtherInspector</a>
        </li>
        <li>
            <a href="./statsOtherSeed.txt">statsOtherSeed</a>
        </li>
        <li>
            <a href="./deterministicDEV/statsDeterministic.txt">statsDeterministic</a>
        </li>
        <li>
            <a href="./deterministicDEV/statsDeterministic1.txt">statsDeterministic1</a>
        </li>
    </ol>
</p>
<p>
    Our simulation cuts off after 2000 minutes of simulation, this can be observed in the two output files:
    <ol>
        <li>
            <a href="./SimulationOutput.txt">SimulationOutput.txt</a>
        </li>
        <li>
            <a href="./deterministicDEV/SimulationOutput.txt">deterministicDEVS/SimulationOutput.txt</a>
        </li>
    </ol>

<h4><a href="./statsOriginal.txt">The original configuration(statsOriginal)</a></h4>
<p>
    In this simulation, 325 products were created. Most of them were accepted the first time and approximately 19.7% of them required reassembly.
    <br>
    The average queue time was over an hour, 74.1 minutes, and the average time in the system was over 5.63 hours. This could be an indication that the system is too slow.
    <br>
    There are very few edge cases when a product had to be reassembled 3 or more times, only 10% of the reassemblies.
</p>

<h4><a href="./statsOtherSeed.txt">Change of Seed configuration(statsOtherSeed)</a></h4>
<p>
    When we changed the seed, roughly the same number of products was produced in the same amount of time(there was only a small increment). Most of them were accepted the first time and approximately 20.1% of them required reassembly.
    <br>
    The average queue time is approximately the same, 74.1 minutes, and the average time spent by products in the system was still over 5.7 hours.
    <br>This was an considerable decrease in performance.
    <br>
    There are more edge cases when a product had to be reassembled 3 or more times, 15% of the reassemblies.
</p>

<h4><a href="./statsOtherInspector.txt">Inspector Change configuration(statsOtherInspector)</a></h4>
<p>
    When we changed the inspector to fixing 20% and trashing 10% (leaving 70% for accepting), more products were produced in the same amount of time(there was a more considerable increment). More of them were accepted the first time, 89.6%, only in 10.35% in the trash.
    <br>
    Approximately 13% of them required reassembly.
    <br>
    The average queue time greatly reduced, 48.7 minutes, and the average time spent by products in the system dropped to just 3.5 hours.
    <br>This showed much better performance.
    <br>
    There are far fewer edge cases when a product had to be reassembled 3 or more times, only 3% of the reassemblies.
    <br>
    In conclusion, this configuration exhibited much better performance overall than the last two.
</p>

<h4><a href="deterministicDEV/statsDeterministic1.txt">Deterministic configuration(statsDeterministic1)</a></h4>
<p>
    The file <a href="./deterministicDEV/statsDeterministic1.txt">statsDeterministic1</a> shows a simulation with the deterministic DEVS.
    In 2000 simulated minutes, the number of products produced is 349, 78.5% of which are accepted while 21.48% were rejected.
    <br>
    Approximately 21.5% of them required reassembly.
    <br>
    The average queue time increased to about 2 hours, and the average time spent by products in the system was 4.7 hours.
    <br>This performance could be improved by tuning the Inspector as shown above.
    <br>
    There are no edge cases when a product had to be reassembled more than 3 times, and only 2 require reassembly 3 times.
 	<br>
 	So we can conclude that the probability that a product will be reassembled 3 or more times is 0.57%, which is good.
    <br>
<!---   In conclusion, a deterministic DEVS model gives us better performance with regard to expected product production, however this could be further improved by a better tuned Inspector.
 <br> Of course, the Inspector can only be tuned according to the standards of the client who shall own the system. --->
</p>

<h2>Deterministic DEVS</h2>
<p>
For the deterministic DEVS, the randomness is taken out of the original DEVS. This is done by taking the in the assignment given mean time of the operators as the running time. 
For the Assembler, this is 4 minutes. For the Inspector it is 2 minutes. The correctness value of the products uses a list of values. For the i-th product that enters the assembler, the i-th value modulo 20 is taken from the list (because the list was initialized with only 20 values).
This list uses values that ensure one of the three decisions of the inspector according to the original assignment. 0 is used for trashing, 0.4 for fixing and 1 for accepting. Using values instead of what it should be assigned as prevented changing the code more than necessary.
It is important to note that this deterministic DEVS cannot be used for inspecting the influence of choosing different percentages for fixing, trashing and accepting due to this design.
As 15% has to be trashed in the assignment, in the list of 20 values 3 are trash values. These 3 values are distributed over the list as well as possible to come as closely as possible to a realistic system. The same goes for the fix values, however as 30% should be fixed, there are 6 values spread across the list.
The rest of the values are accept values.
For calculating the appropriate output, we need to keep the list in mind, and it is therefore given here: <br>
assigningList = [1, 1, 0.4, 1, 1, 0, 0.4, 1, 1, 0.4, 1, 0, 0.4, 1, 1, 0.4, 1, 0, 0.4, 1]
<br> <br>
The first thing to keep in mind is the arrival time of the cylinders and cubes.
A cube arrives each 2 minutes and a cylinder each 3 minutes. 2 cubes and 1 cylinder are needed to form a product.
That means we have enough cubes each 2*2= 4 minutes and enough cylinders each 3 minutes.
From this we can conclude that a product can be made each 4 minutes from the raw materials.
<br><br>
This means that the Assembler first becomes active at time 4 and a new product arrives each 4 minutes. As the delay of the assembler is exactly 4 minutes, there are no queuing times for the assembler if we just take the new products into account and not the ones sent to be fixed.
The Inspector takes 2 minutes to handle a product, as a product can only arrive from the assembler every 4 minutes, there is never a queuing delay for this operator. 
Without keeping fixing in mind, a product will either be accepted or rejected after 4 + 2 = 6 minutes after entering the system and has 2 * 0 minutes of queuing delay (once for the Assembler, and once for Inspector).
The i-th product would be finished after 4 + 4*i + 2. So, product 1 is finished at time 10, product 2 at time 14, etc. The time a product enters the assembler is 4*i. 
<br><br>
If we do take fixing into account, we can see fairly easily that every time a product is marked for fixing all products that arrive in the Assembler after this product have an extra 4 minute delay. The delay keeps adding up for each new product marked to be be fixed.
For our calculations, we need to keep in mind that a queuing delay will not be taken into account until the product has left the operator it is queuing for, and not when it leaves the queue and enters the operator.
The total time in the system will also only be taken into account when the product has either been accepted or rejected.
<br><br>
For the queuing delay of a product at the assembler, it starts at 0. For every fix this amount increases with 4. The fixed product leaves the inspector 2 minutes before the next assembler round starts and a new product arrives, so before the increase with 4, there is a delay of 2 minutes for the fixed product.
Formulas are not easily defined for this system, mostly because of the used assigningList. Some definitions:
<ul>
<li>
	F(t): the amount of products sent to be fixed at time t
</li>
<li>
	A(t): the amount of accepted products at time t
</li>
<li>
	T(t): the amount of trashed products at time t
</li>
<li>
	F(i): the amount of times a product i is sent to be fixed
</li>
<li>
	E(t): time a product enters the system
</li>
<li>
	Ass(i): time a product enters the assembler
</li>
</ul>
<br><br>
From this, we get the formulas:
<ul>
<li>
	time in system (non-fixed) (t) = (4+2) + 4 * T(t)
</li>
<li>
	time in system (fixed) (t) = (4+2) * F(i) + 2 * F(i) + sum(E(t)-> t, F(t))*4<br>
	standard delay * amount of times marked to be fixed + 2 minutes waiting for every fix + 4 minutes waiting every a product is marked to be fixed during its time in the system
</li>
	<li>
	delay (non-fixed) = 4*F(t) + 0 <br>
	amount of product marked to be fixed at time of queuing for assembler + delay for inspector
</li>
<li>
	delay (fixed) = 4*(F(t)-1) + 2 <br>
	4 minutes for every product marked for fixing, excluding the product itself that was just marked (as it causes 4 minutes delay for all subsequent product but not itself) + 2 minutes for waiting till the assembler starts a new round
</li>
<li>
	amount of times queued (i) = 2 + 2(F(i))<br>
	product is queued 2 times (1 time for both Assembler and Inspector) + 2 times for each time the product 
</li>
<li>
	time marking(i) = Ass(i) + 6<br>
	A product can enter the assembler multiple times because of fixing
</li>
</ul>

<br><br> 
Now we see in the assigningList that the first product to be fixed is the third product. This product enters the assembler at time 4*3 = 12. It is marked for fixing at 4*3 + 6 = 18.
Before that marking, another product has entered the assembler at time 4*4 = 16, which is also to be accepted. This product finishes at 4*4 + 6 = 22 and does not have any delays.
The fixable product enters the assembler again at time 5*4 = 20 and leaves the assembler at 20+4 = 24, at which point the queuing delay of 2 is registered. This means that at time 22 we should have 3 accepted products and no queuing delays.
The average time in the system of the products is ((4+2) + (4*0)*3)/3 = 6. This is confirmed in <a href="./deterministicDEV/statsDeterministic22m.txt">statsDeterministic 22 minutes</a>.
<br><br>
Now, the fixed product entered the assembler at time 20. It will finish the inspector at time 20+6 = 26 where it will be accepted. There should be 4 accepted products, of which 1 has been reassembled once.
The amount of times something has left the queue is 2*4 + 2*1 = 10 of which 9 have value 0 and 1 has value 2. The queuing delay should therefore be 2/10=0.2.
The time the last fixed product was in the system is 6*2 + 2 = 14. The average time a product was in the system is therefore 6*3 + 14 / 4 = 8 at time 26. 1/4 =0.25 of these product has been reassembled.
In <a href="./deterministicDEV/statsDeterministic26m.txt">statsDeterministic 26 minutes</a>, we can see this is correct.
<br><br>
At time 24 the next product arrives, which finished at 24+6=30. This is a product to be trashed. The delay at the assembler is 4 minutes because of the previously fixed product.
This makes that there were 2*5 + 2*1 = 12 times a product was queued. The total queue time is 4+2=6, which makes the average queue time 6/12=0.5. The time the product was in the system is 6+4=10.
which makes the average time in the system 6*3 + 14 + 10 / 5 = 42/5 = 8.4. There are 4 accepted products and 1 trashed, making 80% accepted and 20% trashed. This is confirmed by the file <a href="./deterministicDEV/statsDeterministic30m.txt">statsDeterministic 30 minutes</a>
<br><br>
At time 28, the next product to be fixed enters the assembler. This is marked at time 28+6=34 and delays the products arriving in the assembler after that time with a total of 8 minutes (4+4 from the previous product reassembled).
This product has another product in front of it in the queue when it arrives at the assembler. The products that enter the assembler between the time the product enters the assembler for the first time and the second time are both accepted.
At time 40 it can enter the assembler again, and is marked to be fixed again at time 46, making that products arriving after that time have to wait 8+4=12 minutes in the queue.
The products arriving at time 44 and 48 both enter the assembler before the product to be fixed can do it. One is accepted and one trashed, the last one leaves the system at time 54.
This gives an average time in the system of (3*6 + 14 + 3*10 + 2*14) / 9 = (18 + 14 + 20 + 28) / 9 = 90/9 = 10 minutes. 
<br> Amount of times a product is queued = 9*2 + 3*2 = 24. Average queuing time is (2+4*4+6+2*8)/24 = 40/24 = 1.66... 
With 2/9 products trashed, 7/9 accepted and 1/7 accepted products fixed. This matches <a href="./deterministicDEV/statsDeterministic54m.txt">statsDeterministic 54 minutes</a>.
<br><br>
At time 48 + 2*4 = 56, the product that has been fixed twice finally enters the assembler again. This time it is accepted at the inspector at time 56+6 = 62. This would mean that at this time there is a product that has had 2 reassemblies.
This is correct in <a href="./deterministicDEV/statsDeterministic62m.txt">statsDeterministic 62 minutes</a>. This means the behavior of our DEVS is as expected.
</p>



  <h2>Workflow and Task Distribution : </h2>
 <h3>Joanna</h3>
 We both started working on our DEVS models individually and then agreed to go with Danielle's model because hers included the Statistics collector atomic DEVS model as well.
 <br>I then proceeded to document the requirements,assumptions, design, implementation and modelling and simulation results which included checking the model for completeness.

 
 <h3>Daniëlle</h3>
 <p>
 I created the original DEVS model with randomness iteratively, always checking if the behavior was as expected after adding a new AtomicDEVS to the system, mostly using the statistics DEVS for catching anything that could not be connected to the right AtomicDEVS yet.
 From this model, the deterministic model was made. I added the discussion about the correctness of the DEVS to the report and checked the rest of the report for completeness. To parts that were not discussed elaborate enough, extra information was added.
 
 </p>
 <hr noshade>

 </body>
</html>