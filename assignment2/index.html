<html>
 <!-- MoSIS Assignments template -->

 <title>MoSIS Assignment 3</title>

 <body bgcolor="#ffffff">

 <hr noshade>

   <h1>MoSIS Assignment 3</h1>

    <h2>Team</h2>
     <pre>
      Name       :	Daniëlle Jongstra
      Student ID :	20172260
      e-mail     :	Danielle.jongstra@student.uantwerpen.be

      Name       :	Joanna Kisaakye
      Student ID :	20205490
      e-mail     :	joanna.kisaakye@student.uantwerpen.be

      Time spent on this assignment (in hours): 52
     </pre>

    <h2>The assignment</h2>
     <p>
     The last part of each title specifies who (mainly) worked on that part of the assignment.
     </p>
 
    <h2>Solution 1.1.1: IntegratorBlock and DerivatorBlock - Together</h2>

     <p>
	 In the file <a href="./CBDMultipleOutput/Source/CBD.py"><tt>CBD.py</tt></a> the implementation of both the IntegratorBlock and the DerivatorBlock can be found. This code is generated using the drawio CBD tool.
	 The CBD itself is in fig. 1. This is an implementation of the approximating formula ( x(t)-x(t-deltaT) ) / deltaT with deltaT expected to be close to 0 for derivatives. This formula can be recognized in the CBD (fig. 1) by keeping in mind
	 that IN1 is the value of x(t) (x at time t). The delay block its output is x(t-deltaT), which will be negated and added to x(t) (IN1) to get the part x(t)-x(t-deltaT) of the formula.
	 Then the input deltaT will be inverted and multiplied with the previous part we have gotten to obtain the full formula. The IC to the delay block in this CBD is not the inputted IC value, but the outcome of a special IC block.
	 The reason behind this block is that the IC is for the value of the derivative at time zero and not the IC of the value x(0).
	 The block can be seen in fig. 2. The value of the derivative (given by y) at time zero will be the ( x(0) - ICout ) / deltaT. We can use this knowledge to determine the right IC, so that y(0) is the same as ICin.
	 By rewriting the previous formula and bringing over the appropriate variables, we get ICout = -ICin*deltaT + x(0). This is implemented in fig. 2 with IN1 being x(0).

	 
	 
	 <figure>
		<img src="./img/DerBlock.png">
		<figcaption>Figure 1: The CBD for the DerivatorBlock</figcaption>
	</figure> 
	
	<figure>
		<img src="./img/derIc.png">
		<figcaption>Figure 2: The CBD for the IC of DerivatorBlock</figcaption>
	</figure> 
	<br><br>
	For the IntegratorBlock, the forward approximation would not pass the tests, so the backward approximation has been implemented. The value of the integration at time t is <br>
	y(t) = y(t-deltaT) + deltaT*x(t-deltaT). <br>
	The model for this is in fig. 3. The first delay block is for getting the value of x at time t-deltaT instead of x at time t. This delay block has 0 as its initial value, as x(-deltaT) should not influence the value of the integration. The second, upside down, delay block is for keeping the value of y(t-deltaT), 
	the integration value till the current point in time. The IC of this delay block is approached the same way as it was with the DerivatorBlock and can been seen in fig. 4 and implements the formula -x(-deltaT)*deltaT +IC, which is the same as IC because x(-deltaT) is 0. So, this IC block could be left out. 
	The rest of the model is simply following the formula for y(t).
	
	<figure>
		<img src="./img/IntBlock.png">
		<figcaption>Figure 3: The CBD for the IntegratorBlock</figcaption>
	</figure> 
	
	<figure>
		<img src="./img/intIc.png">
		<figcaption>Figure 4: The CBD for the IC of IntegratorBlock</figcaption>
	</figure> 
	<br><br>
	 
	 </p>

    <h2>Solution 1.1.2: Test Approximations - Daniëlle</h2>
 	The formulas of the harmonic oscillator were given in Ordinary Differential Equations, so in this case the CBD using DerivatorBlocks, CBDB, is easier to model.
	In fig. 6 both the CBD modeling the oscillator as the blocks used to determine the error are shown. The top part is the actual model. In this, two DerivatorBlocks are connected.
	The second block is negated, which is the output of x. This x then becomes the input to the first DerivatorBlock for the next time step. x(0) is given to be 0, so the IC to the the second DerivatorBlock is 0.
	Technically speaking you would have to negate the given x(0), as the output of the DerivatorBlock is negated before it is outputted. The value dx/dt for time 0 is given as 1, this is the IC to the first DerivatorBlock.
	The simulation can be found in <a href="harmonicOscillator/CBDB.py"><tt>CBDB.py</tt></a>.
	<br><br>
	The CBD using IntegratorBlocks can be derived from CBDB. Generally speaking, integration is the inverse of the derivation. So, we should take the output of the DerivatorBlock as input to the IntegratorBlock to get the input to the DerivatorBlock.
	In our case, it is mostly a simple replacement of the DerivatorBlocks in CBDB with IntegratorBlocks to get CBDA like in fig. 5. However, this time it is important to keep in mind the the value of x is negated before it is outputted.
	Therefore, the IC to the first IntegratorBlock should be -1 instead of 1. When failing to do this, CBDA is half a period behind on CBDB.
	<br><br>
	The results of the simulation of CBDA and CBDB can be found in fig. 7 respectively fig. 8. This simulation uses 200 steps and is for a deltaT of 0.1 in this case. From these plots, we are expecting CBDA to diverge to unlimited, while CBDB converges to 0 when time is infinite.
	The simulation can be found in <a href="harmonicOscillator/CBDA.py"><tt>CBDA.py</tt></a>.
    <figure>
		<img src="./img/CBDA.png">
		<figcaption>Figure 5: The CBD for the harmonic oscillator using IntegratorBlocks </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDB.png">
		<figcaption>Figure 6: The CBD for the harmonic oscillator using DerivatorBlocks </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDAplot.png">
		<figcaption>Figure 7: Simulation of CBDA with time step deltaT=0.1 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDBplot.png">
		<figcaption>Figure 8: Simulation of CBDB with time step deltaT=0.1</figcaption>
	</figure> 
	<br><br>

    </p>
     
    <h2>Solution 1.1.3: Measure Error - Daniëlle</h2>
	 <p>
	 For measuring the error of both CBDA and CBDB for different time steps, we first plot both simulations for a different deltaT. In fig. 9 and fig. 10 it can be seen that the resulting plots are much more like a graph of a sinus. The amount of simulation steps are set to 20000 to have a graph on the same time interval with deltaT equal to 0.1.
	 The accumulated error is decided using the blocks on the bottom of the model in both fig. 5 and fig. 6. The result of this error is for both models for deltaT equal to 0.1 can be found in fig. 11 and fig. 12.
	 In these figures, it can be seen that the shape of both graphs is approximately the same. However, the accumulated error for CBDA is about 2 times larger than the error in CBDB. 
	 The accumulated error for deltaT equal to 0.001 can be found in fig. 13 and fig. 14. The first thing to notice is that the shapes of the lines are still pretty much the same as the previous plots for deltaT=0.1.
	 However, the error is much smaller for both CBDA and CBDB with deltaT 0.001. The error is now a little over 0.06 instead of being over 8 for CBDA and over 4 for CBDB. The difference between CBDA and CBDB is not as clear for deltaT 0.001 as it was for deltaT 0.1. 
	 That said, the error is still smaller in CBDB at the end of the simulation, even though the difference can hardly be noticed. Concluding, in the case of a long running simulation it is better to use CBDB with a deltaT of 0.001.
	 <figure>
		<img src="./img/CBDA2.png">
		<figcaption>Figure 9: Simulation of CBDA with time step deltaT=0.001 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDB2.png">
		<figcaption>Figure 10: Simulation of CBDB with time step deltaT=0.001 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDAerror.png">
		<figcaption>Figure 11: Accumulated error in CBDA with deltaT = 0.1 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDBerror.png">
		<figcaption>Figure 12: Accumulated error in CBDB with deltaT = 0.1 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDAerror2.png">
		<figcaption>Figure 13: Accumulated error in CBDA with deltaT = 0.001 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDBerror2.png">
		<figcaption>Figure 14: Accumulated error in CBDB with deltaT = 0.001 </figcaption>
	</figure>
	
	 </p>
	 
	<h2>Solution 2.6.1: Look-up Block - Together</h2>
	<p>
	The look-up block can be implemented the same way as all other blocks have been implemented. We use if/else statements to check the time and what the speed should be.
	This is possible, because the input to this block is the current time. The output will be the ideal speed that was specified in the assignment for the current time. 
	The implementation can be found in <a href="./CBDMultipleOutput\Source\ComputerBlock.py"><tt>ComputerBlock.py</tt></a>.
	</p>

 	<h2>Solution 2.6.2: Build and simulate the Driver-less train CBD Model - Joanna</h2>
	<p>
		Our implementation of the Driver-less CBD model features separate causal block diagrams that we merge into a causal block diagram that represents the complete Driver-less CBD model.
		The blocks are implemented according to the equations included in the Assignment PDF and the full implementation is in the files <a href="trainModel/TrainCBD.drawio"><tt>TrainCBD.drawio</tt></a>
		and <a href="trainModel/TrainCBD.py"><tt>TrainCBD.py</tt></a>
		<br>
		The blocks that make up the Driver-less train CBD are displayed in figures 15 to 20.
	</p>
	<figure>
		<img src="./img/PID.png">
		<figcaption>Figure 15: PID Controller Block</figcaption>
	</figure>

 	<p>
		The Train Time Block has an extra property h, the time interval between two simulation steps, which we decided to initialise as 0.1.
	</p>
	<figure>
		<img src="./img/Train Time.png">
		<figcaption>Figure 16: Train Time Block</figcaption>
	</figure>

 	<p>
		In the case of the equations for the train and the passenger, we chose to implement the equations in two separate CBDs for clarity.
	</p>
	<figure>
		<img src="./img/Train Block.png">
		<figcaption>Figure 17: Train Block which outputs the velocity and acceleration of the train</figcaption>
	</figure>
	<figure>
		<img src="./img/Passenger Block.png">
		<figcaption>Figure 18: Passenger Block which outputs the displacement and acceleration fo the passenger</figcaption>
	</figure>

 	<p>
		After the blocks created in the former figures 17 and 18, the plant block is just a block that amalgamates the two and produces all their outputs.
	</p>
	<figure>
		<img src="./img/Plant Block.png">
		<figcaption>Figure 19: Plant Block</figcaption>
	</figure>

 	<p>
		The Train CBD has extra properties, Kd, Ki and Kp which are used later during the Tuning process.
	</p>
	<figure>
		<img src="./img/Train CBD.png">
		<figcaption>Figure 20: Train CBD</figcaption>
	</figure>

 	<p>
		After creating our CBD, we were able to generate the graphs in figures 21 and 22 in using the step size of 3500.
	</p>

	<figure>
		<img src="./img/ideal vs actual.png">
		<figcaption>Figure 21: Ideal and Actual velocity of train (200,0,0)</figcaption>
	</figure>
	<figure>
		<img src="./img/train acceleration vs person displacement.png">
		<figcaption>Figure 22: Person Displacement and Train acceleration (200,0,0)</figcaption>
	</figure>

 	<h2>Solution 2.6.3:  Tune the PID controller - Together</h2>
	<p>
		We decided to tune our PID controller automatically by creating an extra block, <b>TrainTuningBlock</b> in <a href="trainModel/TrainCBD.drawio"><tt>TrainCBD.drawio</tt></a> that
		features the CostFunctionBlock getting the output of TrainCBD as input and producing the cost. This allowed us to create a CBD that we could use in the tuning function in
		<a href="trainModel/TrainTuning.py"><tt>TrainTuning.py</tt></a>, which tuning function produced the results in figure 24.
	</p>

	<figure>
		<img src="./img/Train Tuning Block.png">
		<figcaption>Figure 23: Train Tuning Block</figcaption>
	</figure>
	<figure>
		<img src="./img/Tuning Results.png">
		<figcaption>Figure 24: Tuning Results</figcaption>
	</figure>
	<p>
		From the results, we can surmise that within the limits given in the assignment, 9 is the most optimal value for Ki, with Kd in the range of 180 to 182 and Kp in the range of 565 to 570.
		We also see that Kp is further dependent on the value of Kd, as Kd increases by 1 the range of values of Kp for which we get an optimal result reduces by two.
		The output of our simulation of the costs is in <a href="./pycharm_console.log"><tt>pycharm_console.log</tt></a>.
	</p>


 	<p>
		Figure 25 shows the full Driver-less train CBD with the Tuning Block included.
	</p>
	<figure>
		<img src="./img/TrainCBD.svg">
		<figcaption>Figure 25: Full Driver-less Train CBD</figcaption>
	</figure>


 <hr noshade>

 </body>
</html>