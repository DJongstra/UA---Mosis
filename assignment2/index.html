<html>
 <!-- MoSIS Assignments template -->

 <title>MoSIS Assignment 3</title>

 <body bgcolor="#ffffff">

 <hr noshade>

   <h1>MoSIS Assignment 3</h1>

    <h2>Team</h2>
     <pre>
      Name       :	Daniëlle Jongstra
      Student ID :	20172260
      e-mail     :	Danielle.jongstra@student.uantwerpen.be

      Name       :	Joanna Kisaakye
      Student ID :	20205490
      e-mail     :	joanna.kisaakye@student.uantwerpen.be

      Time spent on this assignment (in hours): TO FILL IN
     </pre>

    <h2>The assignment</h2>
     <p>
     The last part of each title specifies who (mainly) worked on that part of the assignment.
     </p>
 
    <h2>Solution 1.1.1: IntegratorBlock and DerivatorBlock - Together</h2>

     <p>
	 In the file <a href="./CBDMultipleOutput/Source/CBD.py"><tt>CBD.py</tt></a> the implementation of both the IntegratorBlock and the DerivatorBlock can be found. This code is generated using the drawio CBD tool.
	 The CBD itself is in fig. 1. This is an implementation of the approximating backward formula ( x(t)-x(t-deltaT) ) / deltaT with deltaT expected to be close to 0 for derivatives. This formula can be recognized in the CBD (fig. 1) by keeping in mind
	 that IN1 is the value of x(t) (x at time t). The delay block its output is x(t-deltaT), which will be negated and added to x(t) (IN1) to get the part x(t)-x(t-deltaT) of the formula.
	 Then the input deltaT will be inverted and multiplied with the previous part we have gotten to obtain the full formula. The IC to the delay block in this CBD is not the inputted IC value, but the outcome of a special IC block.
	 The reason behind this block is that the IC is for the value of the derivative at time zero and not the IC of the value x(0).
	 The block can be seen in fig. 2. The value of the derivative (given by y) at time zero will be the ( x(0) - ICout ) / deltaT. We can use this knowledge to determine the right IC, so that y(0) is the same as ICin.
	 By rewriting the previous formula and bringing over the appropriate variables, we get ICout = -ICin*deltaT + x(0). This is implemented in fig. 2 with IN1 being x(0).

	 
	 
	 <figure>
		<img src="./img/DerBlock.png">
		<figcaption>Figure 1: The CBD for the DerivatorBlock</figcaption>
	</figure> 
	
	<figure>
		<img src="./img/derIc.png">
		<figcaption>Figure 2: The CBD for the IC of DerivatorBlock</figcaption>
	</figure> 
	<br><br>
	For the IntegratorBlock, the forward approximation would not pass the tests, so the backward approximation has been implemented. The value of the integration at time t is <br>
	y(t) = y(t-deltaT) + deltaT*x(t-deltaT). <br>
	The model for this is in fig. 3. The first delay block is for getting the value of x at time t-deltaT instead of x at time t. This delay block has 0 as its initial value, as x(-deltaT) should not influence the value of the integration. The second, upside down, delay block is for keeping the value of y(t-deltaT), 
	the integration value till the current point in time. The IC of this delay block is approached the same way as it was with the DerivatorBlock and can been seen in fig. 4 and implements the formula -x(-deltaT)*deltaT +IC, which is the same as IC because x(-deltaT) is 0. So, this IC block could be left out. 
	The rest of the model is simply following the formula for y(t).
	
	<figure>
		<img src="./img/IntBlock.png">
		<figcaption>Figure 3: The CBD for the IntegratorBlock</figcaption>
	</figure> 
	
	<figure>
		<img src="./img/intIc.png">
		<figcaption>Figure 4: The CBD for the IC of IntegratorBlock</figcaption>
	</figure> 
	<br><br>
	 
	 </p>

    <h2>Solution 1.1.2: Test Approximations - Daniëlle</h2>
 	The formulas of the harmonic oscillator were given in Ordinary Differential Equations, so in this case the CBD using DerivatorBlocks, CBDB, is easier to model.
	In fig. 6 both the CBD modeling the oscillator as the blocks used to determine the error are shown. The top part is the actual model. In this, two DerivatorBlocks are connected.
	The second block is negated, which is the output of x. This x then becomes the input to the first DerivatorBlock for the next time step. x(0) is given to be 0, so the IC to the the second DerivatorBlock is 0.
	Technically speaking you would have to negate the given x(0), as the output of the DerivatorBlock is negated before it is outputted. The value dx/dt for time 0 is given as 1, this is the IC to the first DerivatorBlock.
	The simulation can be found in <a href="./CBDB.py"><tt>CBDB.py</tt></a>.
	<br><br>
	The CBD using IntegratorBlocks can be derived from CBDB. Generally speaking, integration is the inverse of the derivation. So, we should take the output of the DerivatorBlock as input to the IntegratorBlock to get the input to the DerivatorBlock.
	In our case, it is mostly a simple replacement of the DerivatorBlocks in CBDB with IntegratorBlocks to get CBDA like in fig. 5. However, this time it is important to keep in mind the the value of x is negated before it is outputted.
	Therefore, the IC to the first IntegratorBlock should be -1 instead of 1. When failing to do this, CBDA is half a period behind on CBDB.
	<br><br>
	The results of the simulation of CBDA and CBDB can be found in fig. 7 respectively fig. 8. This simulation uses 200 steps and is for a deltaT of 0.1 in this case. From these plots, we are expecting CBDA to diverge to unlimited, while CBDB converges to 0 when time is infinite.
	The simulation can be found in <a href="./CBDA.py"><tt>CBDA.py</tt></a>.
    <figure>
		<img src="./img/CBDA.png">
		<figcaption>Figure 5: The CBD for the harmonic oscillator using IntegratorBlocks </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDB.png">
		<figcaption>Figure 6: The CBD for the harmonic oscillator using DerivatorBlocks </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDAplot.png">
		<figcaption>Figure 7: Simulation of CBDA with time step deltaT=0.1 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDBplot.png">
		<figcaption>Figure 8: Simulation of CBDB with time step deltaT=0.1</figcaption>
	</figure> 
	<br><br>

    </p>
     
    <h2>Solution 1.1.3: Measure Error - Daniëlle</h2>
	 <p>
	 For measuring the error of both CBDA and CBDB for different time steps, we first plot both simulations for a different deltaT. In fig. 9 and fig. 10 it can be seen that the resulting plots are much more like a graph of a sinus. The amount of simulation steps are set to 20000 to have a graph on the same time interval als with deltaT equal to 0.1.
	 The accumulated error is decided using the blocks on the bottom of the model in both fig. 5 and fig. 6. The result of this error is for both models for deltaT equal to 0.1 can be found in fig. 11 and fig. 12.
	 In these figures, it can be seen that the shape of both graphs is approximately the same. However, the accumulated error for CBDA is about 2 times larger than the error in CBDB. 
	 The accumulated error for deltaT equal to 0.001 can be found in fig. 13 and fig. 14. The first thing to notice is that the shapes of the lines are still pretty much the same as the previous plots for deltaT=0.1.
	 However, the error is much smaller for both CBDA and CBDB with deltaT 0.001. The error is now a little over 0.06 instead of being over 8 for CBDA and over 4 for CBDB. The difference between CBDA and CBDB is not as clear for deltaT 0.001 as it was for deltaT 0.1. 
	 However, the error for still smaller in CBDB at the end of the simulation, even though the difference can hardly be noticed. Concluding, in case of a long running simulation it is better to use CBDB with a deltaT of 0.001.
	 <figure>
		<img src="./img/CBDA2.png">
		<figcaption>Figure 9: Simulation of CBDA with time step deltaT=0.001 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDB2.png">
		<figcaption>Figure 10: Simulation of CBDB with time step deltaT=0.001 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDAerror.png">
		<figcaption>Figure 11: Accumulated error in CBDA with deltaT = 0.1 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDBerror.png">
		<figcaption>Figure 12: Accumulated error in CBDB with deltaT = 0.1 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDAerror2.png">
		<figcaption>Figure 13: Accumulated error in CBDA with deltaT = 0.001 </figcaption>
	</figure> 
	<figure>
		<img src="./img/CBDBerror2.png">
		<figcaption>Figure 14: Accumulated error in CBDB with deltaT = 0.001 </figcaption>
	</figure> 
	
	 </p>
	 
	<h2>Solution 2.6.1: Look-up Block - Together</h2>
	<p>
	The look-up block can be implemented the same way as all other blocks have been implemented. We use if/else statements to check the time and what the speed should be.
	This is possible, because the input to this block is the current time. The output will be the ideal speed that was specified in the assignment for the current time. 
	The implementation can be found in <a href="./CBDMultipleOutput\Source\ComputerBlock.py"><tt>ComputerBlock.py</tt></a>.
	</p>

 <hr noshade>

 </body>
</html>