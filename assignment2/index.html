<html>
 <!-- MoSIS Assignments template -->

 <title>MoSIS Assignment 2</title>

 <body bgcolor="#ffffff">

 <hr noshade>

   <h1>MoSIS Assignment N</h1>

    <h2>Team</h2>
     <pre>
      Name       :	Daniëlle Jongstra
      Student ID :	20172260
      e-mail     :	Danielle.jongstra@student.uantwerpen.be

      Name       :	Joanna Kisaakye
      Student ID :	20205490
      e-mail     :	joanna.kisaakye@student.uantwerpen.be

      Time spent on this assignment (in hours):
     </pre>

    <h2>The assignment</h2>
     <p>
     The last part of each title specifies who (mainly) worked on that part of the assignment.
     </p>
 
    <h2>Solution 2&3: Discrete-Time CBD simulator - Together</h2>

     <p>
	 For this part, we filled in all the blanks in the file <a href="./CBDMultipleOutput/Source/CBD.py"><tt>CBD.py</tt></a>. The compute functions now use the input signals of the block
	 to get the correct signal generated by the block. How these input signals are used exactly depend on the kind of block we are computing.
	 <br><br>
	 The getDependencies function in the class DelayBlock also needed to be implemented. This block has no algebraic dependencies, except for the first iteration (time = 0).
	 During the first iteration, it depends on the block connected to the IC port. This is implemented as a condition on the current iteration and returns the block connected
	 to IC if the iteration is 0, else it returns and empty list.
	 <br><br>
	 A causal block diagram can contain strong components, which are loops. For such a strong component, its values can be computed by solving a linear set of equations. To be able to do this,
	 the blocks in the strong component have to be representable by a linear equation. Blocks such as the comparison blocks, the modulo block and the logical and and or block can not be represented as a linear equation.
	 In checking the linearity of the strong component, the function returns false if one of these blocks are encountered. The product block is a special case. It can be represented as a linear equation if at least one of 
	 the values of the input ports is known, else it is not linear and a false value is returned by the function checking for linearity. If the product block has at least one known input and all other blocks in the strong component are also linear, then the strong component is linear
	 and the checking function returns a true value.
	 
	 </p>

    <h2>Solution 4: Discrete-Time CBD Denotational Semantics - Joanna</h2>
 	<br>
        To create the LaTeX required to represent the denotational semantics of our models, we created a class called LaTeXGenerator in <a href="./LaTeXGenerator.py"><tt>LaTeXGenerator.py</tt></a>. It has one main function,
        generateLateX() that takes a CBD instance as input. The class maintains an array of equation strings and the following is a brief walk through of the generateLateX() function, specifically focussing on how those strings are generated by it:
        <br><br>
        The first thing the generateLateX() function does is call the flatten function of the cbd and then store the collection of blocks in a variable called blocks. It then loops over the blocks the first time. In the first round of looping,
        it assigns variable letters for each block, each input port and each output port of that block. Within the same loop, after assigning variable names to the ports, it adds an assignment equation of the form
        var(inputport) = var(outputport) to represent the connection of those ports.
        <br><br/>
        During the second round of looping through the blocks is when the equations for the operators represented by the blocks are added to the equation array. This second loop is necessary because in the first loop not all the blocks and ports have been
        assigned variables. For each block, the constructOperatorEquation() function is called, which categorises block operations according to where the operator is positioned with regard to the operands (in accordance to LaTeX syntax) and calls the appropriate helper function among these;
        constructOperatorInBetweenEquation(), constructOperatorGoesBeforeEquation(), constructOperatorSurroundsEquation(), constructInverterEquation(), constructRootEquation(), constructConstantAssignmentEquation() and constructDelayBlockAssignmentEquation(). Each of those functions, loops through the inputs and creates a
        string that represents the equation of the block in a format that is acceptable to LaTeX.
        <br><br/>
        Once we have all our equation strings, we simply create a LaTeX file using Python File operations and write to the file. Finally, we also include a subprocess call to generate a PDF from the LaTeX file.
        <br></br>
        The following are samples of the LaTeX and PDf files generated by <a href="./LaTeXGenerator.py"><tt>LaTeXGenerator.py</tt></a>:
        <ul>
            <li><a href="./EvenNumberGen.tex"><tt>EvenNumberGen.tex</tt></a> and <a href="./EvenNumberGen.pdf"><tt>EvenNumberGen.pdf</tt></a></li>
            <li><a href="./fibonacci_gen.tex"><tt>fibonacci_gen.tex</tt></a> and <a href="./fibonacci_gen.pdf"><tt>fibonacci_gen.pdf</tt></a></li>
            <li><a href="./SinGen.tex"><tt>SinGen.tex</tt></a> and <a href="./SinGen.pdf"><tt>SinGen.pdf</tt></a></li>
            <li><a href="./Random.tex"><tt>Random.tex</tt></a> and <a href="./Random.pdf"><tt>Random.pdf</tt></a></li>
            <li><a href="./Implicit.tex"><tt>Implicit.tex</tt></a> and <a href="./Implicit.pdf"><tt>Implicit.pdf</tt></a></li>
            <li><a href="./Explicit.tex"><tt>Explicit.tex</tt></a> and <a href="./Explicit.pdf"><tt>Explicit.pdf</tt></a></li>
        </ul>

    </p>
     
    <h2>Solution 5: Pseudo-Random Number Generator - Daniëlle</h2>
	 <p>
	<figure>
		<img src="./img/random.png">
		<figcaption>Figure 1: The CBD for the pseudo-random number generator</figcaption>
	</figure> 
	
	In figure 1, is the CBD for the pseudo-random number generator. To view this on <a href="https://www.diagrams.net/"><tt>diagrams.net</tt></a> import the file <a href="./Pseudo-Random.drawio"><tt>Pseudo-Random.drawio</tt></a>.
	From this drawio file the python CBD has automatically been generated in <a href="./pseudo-random.py"><tt>pseudo-random.py</tt></a>. The initial value x0 is a constant 0 in figure 1. In the implementation this block can be assigned any constant number in the initialization of the CBD.
	By using a constant block instead of a input port for x0 in the drawing, there was no need to manually make a constant block to connect to the input port of x0. The only thing needed to be done was adding a input variable to the initialization of the CBD and 
	giving the constant block x0 the value of this variable. By running <a href="./pseudo-random.py"><tt>pseudo-random.py</tt></a>, the CBD is automatically simulated for every value x0 between 0 and 8. The period for every x0 is 9, so the generator its period does not depend on the initial x.
	
	</p>
	
	<h2>Solution 6: Explicit vs. Implicit Equations - Daniëlle</h2>
	<p>
	<figure>
		<img src="./img/sinCBD.png">
		<figcaption>Figure 2: The CBD for the sinus function</figcaption>
	</figure> 
	The result of the implicit and explicit equations needs to be compared to values of the sinus function. The CBD for this sinus function is in figure 2. The value of D is multiplied with the clock value to get the right steps size.
	The rest of the CBD is the same as the example <a href="./examples/SinGen/SinGen.xml"><tt>SinGen.xml</tt></a>.
	<br><br>
	<figure>
		<img src="./img/explicitCBD.png">
		<figcaption>Figure 3: The CBD for the set of explicit equations</figcaption>
	</figure> 
	The CBD for the explicit equations is shown in figure 3 and is also in <a href="./ExplicitEquation.drawio"><tt>ExplicitEquation.drawio</tt></a>. The delay blocks contain the values of x and y.
	For the explicit equations, the values that the delay blocks output are immediately used to calculate the next value of x and y. The value of D is a constant 0.1 in figure 3, however it can change and for this the same approach is used as for x0 in part 5 of the assignment.
	The outputs for every iteration i are the value of x(i), y(i) and sinus(Di).
	<figure>
		<img src="./img/explicit1.png">
		<figcaption>Figure 4: The results of the simulation for the explicit equations using D = 0.1</figcaption>
	</figure> 
	<figure>
		<img src="./img/explicit2.png">
		<figcaption>Figure 5: The results of the simulation for the explicit equations using D = 0.001</figcaption>
	</figure> 
	The python simulation of the explicit CBD can be found in <a href="./explicit.py"><tt>explicit.py</tt></a>. The results for D=0.1 and D=0.001 are in figure 4 and figure 5.
	It can be seen that D=0.001 almost falls together with the actual sinus function. For D=0.1 the difference is quite big, approximately 0.25. 
	<br><br>
	
	<figure>
		<img src="./img/implicitCBD.png">
		<figcaption>Figure 6: The CBD for the set of implicit equations</figcaption>
	</figure> 
	The CBD for the implicit equations is shown in figure 6 and is also in <a href="./ImplicitEquation.drawio"><tt>ExplicitEquation.drawio</tt></a>. These equations do not immediately use the values of x and y,
	but first calculate the next value of y to calculate x, and x to calculate y. Because of this, there is a strong component in the CBD. For the value of D in this CBD, the same thing applies as for D in the explicit CBD.
	The outputs for every iteration i are the value of x(i), y(i) and sinus(Di).
	<figure>
		<img src="./img/implicit1.png">
		<figcaption>Figure 7: The results of the simulation for the implicit equations using D = 0.1</figcaption>
	</figure> 
	<figure>
		<img src="./img/implicit2.png">
		<figcaption>Figure 8: The results of the simulation for the implicit equations using D = 0.001</figcaption>
	</figure> 
	The python simulation of the implicit CBD can be found in <a href="./implicit.py"><tt>implicit.py</tt></a>. The results for D=0.1 and D=0.001 are in figure 7 and figure 8.
	For D=0.001 the values again almost fall together with the sinus function, just as in the simulation for the explicit equations. For D=0.1, the difference with the sinus function is approximately 0.25.
	<br><br>
	In conclusion, D approaching but not equal to zero is better to model the sinus function than a larger D. There is not a big difference in error for using implicit equations or explicit equations.
	However, the implicit equations model stays within the bounds of the sinus while the explicit equations model does not. This might be important, depending on which situation the model is used for.
	
	</p>

 <hr noshade>

 </body>
</html>