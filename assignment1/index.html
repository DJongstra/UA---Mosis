<html>
 <!-- MoSIS Assignments template -->

 <title>MoSIS Assignment 1</title>

 <body bgcolor="#ffffff">

 <hr noshade>

   <h1>MoSIS Assignment 1</h1>

    <h2>Team</h2>
     <pre>
      Name       :	DaniÃ«lle Jongstra
      Student ID :	20172260
      e-mail     :	Danielle.jongstra@student.uantwerpen.be

      Name       :	Joanna Kisaakye
      Student ID :	20205490
      e-mail     :	joanna.kisaakye@student.uantwerpen.be

      Time spent on this assignment (in hours):
     </pre>

    <h2>The assignment</h2>
     <p>
     Possibly some of your own clarifications or extra assumptions.
     </p>
	 
    <h2>Solution part 1 : Class Diagram</h2>
	
	<figure>
		<img src="ClassDiagram.png">
		<figcaption>Figure 1: Class diagram corresponding to the implementation of <a href="./chatProtocolSimulation.py"><tt>chatProtocolSimulation.py</tt></a></figcaption>
	</figure> 
	
	<p>
	For the class diagram the implementation given in <a href="./chatProtocolSimulation.py"><tt>chatProtocolSimulation.py</tt></a> is followed as much as possible.
	The class, or static, attributes in the Chatroom and Client classes are underlined. The other attributes are initialized for each instance of the classes and are therefore not underlined.
	All the attributes and methods are considered public in this class diagram. It is not possible to declare either the attributes or the methods private in python, 
	but it is seen as a safe assumption since the convention is to use an underscore as the first character in the name for a method or attribute that would in other programming languages be declared private.
	<br><br>
	The cardinalities in the diagram are assigned between the classes of Chatroom and Client.
	For each Client there is 0 or 1 Chatroom, as a client can either be in one chat room or in no chat room when he/she still has to connect to one.
	The textual description on <a href="http://msdl.cs.mcgill.ca/people/hv/teaching/MoSIS/assignments/requirementsChecking"><tt>the assignment web page</tt></a> specifies that a chat room can accept at most four clients. 
	The cardinality constraint 0...4 in the diagram specifies this.
	<br><br>
	The relationship between Manager and Client is a normal association. It is clearly not a realization or generalization. 
	The relationship is also not a dependency, as neither of the classes are an attribute of the other class. 
	If we do not look too closely at the implementation, it could be an has-a relationship. The Manager has (a list of) client(s) in that case. 
	Considering that the relationship between Chatroom and Manager is similar to the relationship of Manager and Client, the same thought process is followed for this relationship.
	Now we should also keep in mind that the class Chatroom also calls methods of the class Manager. 
	In a has-a relationship the Manager would know about the Chatroom, but not the other way around. Because the similarity of the relationships, neither of the relationships with the Manager class are specified as a has-a relationship. 
	</p>
	
    <h2>Solution part 2 : Sequence Diagrams</h2>
     
    <figure>
		<img src="SequenceDiagram1.png">
		<figcaption>Figure 2: Sequence diagram corresponding Use Case 3 according to the implementation of <a href="./chatProtocolSimulation.py"><tt>chatProtocolSimulation.py</tt></a></figcaption>
	</figure>
    <p>
        According to the implementation in chatProtocolSimulation.py, a chat room accepts a client within its request method by calling the accept method of the Manager. The Manager then calls the accept method of the client which is responsible for changing the clients state to reflect that it is now connected to a chatroom. The Manager also updates its state, within its own accept method, by appending the client, room pair to its map of connections.
        <br>
        Since none of the accept methods of the Client or Manager return anything to the caller, the Chatroom proceeds to dump to the output by printing the Manager.
    </p>
    <figure>
		<img src="SequenceDiagram2.png">
		<figcaption>Figure 3: Sequence diagram corresponding Use Case 7 according to the implementation of <a href="./chatProtocolSimulation.py"><tt>chatProtocolSimulation.py</tt></a></figcaption>
	</figure>
    <p>
        According to the implementation in chatProtocolSimulation.py, when a Manager receives a call to its sendMessage method, it in turn calls the sendMessage method of the chatroom. That sendMessage method calls the broadcast method of the Manager.
        <br>
        Within the Manager, the broadcast method calls the broadcast method of all connected clients. This diverts from the use case because there is supposed to be a check to ensure that the client that sent the message does not receive the message, as shown in the sequence diagram in Figure 3 above.
    </p>

    <h2>Solution part 3 : Regular Expressions and Finite State Automata</h2>

    <figure>
		<img src="useCase3FSA.png">
		<figcaption>Figure 4: Use Case 3 Finite State Automata according to the implementation of <a href="./chatProtocolSimulation.py"><tt>chatProtocolSimulation.py</tt></a></figcaption>
	</figure>
    <p>
        <br>
    </p>
    <figure>
		<img src="useCase7FSA.png">
		<figcaption>Figure 5: Use Case 7 Finite State Automata according to the implementation of <a href="./chatProtocolSimulation.py"><tt>chatProtocolSimulation.py</tt></a></figcaption>
	</figure>
    <p>
        <br>
    </p>

    <h2>Solution part 4 : Implementation Bug Fix</h2>

    <figure>
		<img src="Bug fix screenshot.png">
		<figcaption>Figure 6: Fixed code in <a href="./chatProtocolSimulationFixed.py"><tt>chatProtocolSimulationFixed.py</tt></a></figcaption>
	</figure>
    <p>
        To fix the implementation bug present in chatProtocolSimulation.py, we add an extra line to the broadcast method of the manager that checks that the client Id of the client receiving the message is not the same as the sender Id.
    </p>

 <hr noshade>

 </body>
</html>